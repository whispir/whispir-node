import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { ApiError, ApiErrorWrite } from '../model/apiError';
import { Auth, AuthWrite } from '../model/auth';
import { ObjectSerializer, Interceptor } from '../model/models';
import { HttpError, RequestFile, ApiConfig, RequestOptions } from './apis';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class AuthApi {
    protected defaultHeaders: any = {};
    protected useQuerystring: boolean = false;
    protected interceptors: Interceptor[] = [];
    protected host: string;

    constructor(config: ApiConfig) {
        this.defaultHeaders = config.defaultHeaders;
        this.host = config.host;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Verify a JWT authentication token
     * @summary Verify an auth token
     * @param xApiKey The API key for authentication.
     * @param accept Application specific mime-type
     */
    public async retrieveVerification(params?: {
    }, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage }> {
        const {
        } = params || {};

        const localVarPath = this.host + '/auth/verify';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        localVarHeaderParams['Accept'] = 'application/vnd.whispir.auth-v1+json';
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            
                            resolve({ lastResponse: response.toJSON(), ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a JWT authentication token
     * @summary Create an auth token
     * @param xApiKey The API key for authentication.
     * @param contentType Application specific mime-type
     * @param accept Application specific mime-type
     */
    public async create(params?: {
    }, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage, id: string } & Auth> {
        const {
        } = params || {};

        const localVarPath = this.host + '/auth';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        localVarHeaderParams['Content-Type'] = 'application/vnd.whispir.auth-v1+json';
        localVarHeaderParams['Accept'] = 'application/vnd.whispir.auth-v1+json';
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Auth");
                            
                            // Special case to extract the resource identifier from the `Location` header.
                            const checkLocation = response?.headers?.location?.match(/\/([^\/]+)\/?$/);
                            let id = (checkLocation && checkLocation[1]) ? checkLocation[1] : undefined;
                            
                            resolve({ lastResponse: response.toJSON(), id, ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
