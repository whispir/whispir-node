import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Contact } from '../model/contact';
import { GetContacts200Response } from '../model/getContacts200Response';
import { GetMessages400Response } from '../model/getMessages400Response';
import { GetMessages401Response } from '../model/getMessages401Response';
import { GetMessages403Response } from '../model/getMessages403Response';
import { GetMessages404Response } from '../model/getMessages404Response';
import { GetMessages405Response } from '../model/getMessages405Response';
import { GetMessages415Response } from '../model/getMessages415Response';
import { GetMessages422Response } from '../model/getMessages422Response';
import { GetMessages500Response } from '../model/getMessages500Response';
import { GetMessages501Response } from '../model/getMessages501Response';
import { ObjectSerializer, Interceptor } from '../model/models';
import { HttpError, RequestFile, ApiConfig, RequestOptions } from './apis';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class ContactsApi {
    protected defaultHeaders: any = {};
    protected useQuerystring: boolean = false;
    protected interceptors: Interceptor[] = [];
    protected host: string;

    constructor(config: ApiConfig) {
        this.defaultHeaders = config.defaultHeaders;
        this.host = config.host;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * After performing this request, the response does not contain any information other than the headers as it is not necessary.  The user has requested to delete a contact, and when the response of 204 No Content is returned, the contact is successfully deleted. 
     * @summary Delete a contact
     * @param workspaceId The identifier for the workspace.
     * @param xApiKey The API key for authentication.
     * @param contactId The id of the contact to be deleted
     * @param action The API call involves passing an &#x60;action&#x3D;deleteAll&#x60; query parameter. Once this action is triggered, all the contact references in all workspaces for a given &#x60;contact_id&#x60; are deleted asynchronously. There is no way to stop the process once it\&#39;s triggered. **Use the action only when you\&#39;re definitely sure you want to delete the contact from all workspaces**
     */
    public async delete(params?: {
        workspaceId: string,
        contactId: string,
        action?: 'deleteAll',
    }, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage }> {
        const {
            workspaceId,
            contactId,
            action,
        } = params || {};

        const localVarPath = this.host + '/workspaces/{workspaceId}/contacts/{contactId}'
            .replace('{' + 'workspaceId' + '}', encodeURIComponent(String(workspaceId)))
            .replace('{' + 'contactId' + '}', encodeURIComponent(String(contactId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        if (action !== undefined) {
            localVarQueryParameters['action'] = ObjectSerializer.serialize(action, "'deleteAll'");
        }
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            
                            resolve({ lastResponse: response.toJSON(), ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Note:** There is no global search feature available where one can search on all the workspaces present in the system (under allowed user permission). So, When no workspace is provided, the search is performed on the default workspace of the user.  ### Searching for contacts with Custom Fields  As Whispir supports extension of the default Contact Profile through the use of Custom Fields. There may be cases where users want to search for Contacts that contain these specific fields. As such, the Whispir API supports searching for contacts using these custom fields.  Any custom field can be searched by adding the custom_ prepended to the name.  For example, if the field name is **StaffId**, then the URL would search for:  `/contacts?custom_StaffId=12345` 
     * @summary List contacts
     * @param workspaceId The identifier for the workspace.
     * @param xApiKey The API key for authentication.
     * @param accept Application specific mime-type.
     * @param limit The number of records to be returned.
     * @param offset The record number to start returning from.
     * @param sortOrder The order in which you require the results to be returned. Either ‘asc’ or ‘desc’
     * @param sortFields The fields that you require the ordering to be performed on. Multiple fields can be provided, separated by a comma.
     * @param fieldname String Specifies the field name of the contact object. The field name could be any thing as long as it is a valid contact attribute.   Example: &#x60;http://api.whispir.com/contacts?firstName&#x3D;Sam&#x60; 
     * @param customFields Custom Fields
     */
    public async list(params?: {
        workspaceId: string,
        limit?: number,
        offset?: number,
        sortOrder?: 'asc' | 'desc',
        sortFields?: string,
        fieldname?: string,
        customFields?: boolean,
    }, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage } & GetContacts200Response> {
        const {
            workspaceId,
            limit = 20,
            offset = 0,
            sortOrder,
            sortFields,
            fieldname,
            customFields,
        } = params || {};

        const localVarPath = this.host + '/workspaces/{workspaceId}/contacts'
            .replace('{' + 'workspaceId' + '}', encodeURIComponent(String(workspaceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (sortOrder !== undefined) {
            localVarQueryParameters['sortOrder'] = ObjectSerializer.serialize(sortOrder, "'asc' | 'desc'");
        }
        if (sortFields !== undefined) {
            localVarQueryParameters['sortFields'] = ObjectSerializer.serialize(sortFields, "string");
        }
        if (fieldname !== undefined) {
            localVarQueryParameters['fieldname'] = ObjectSerializer.serialize(fieldname, "string");
        }
        if (customFields !== undefined) {
            localVarQueryParameters['customFields'] = ObjectSerializer.serialize(customFields, "boolean");
        }
        localVarHeaderParams['Accept'] = 'application/vnd.whispir.contact-v1+json';
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetContacts200Response");
                            
                            resolve({ lastResponse: response.toJSON(), ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * ### Showing Custom Fields  Whispir supports extension of the default Contact Profile through the use of Custom Fields. Custom fields can support other fields that may be required to be stored on your Contacts, such as Staff ID, Internal Billing Codes, or One Up Manager.  These custom fields can be configured on any account through a Change Request to Whispir.  In order to reveal these custom fields on the contact profile, you can use the `customFields=true` flag within your API request.  Example: `/contacts/AB38CB3EFD38AFDB?customFields=true` 
     * @summary Retrieve a contact
     * @param workspaceId The identifier for the workspace.
     * @param xApiKey The API key for authentication.
     * @param contactId Enter contact id.
     * @param accept Application specific mime-type.
     * @param fields NOTE: once again, the equal sign must be intended as \&quot;contains\&quot; rather than \&quot;equals\&quot;. So if we search the people whose firstName equals Sam we might be given back e.g. Sam, Samantha, Samuel. Similarly for numbers: if we search Contacts with staffId equal to 1234 we will given back e.g. the contact with staffID equal to 1234 but also e.g. a contact with staffID equal to 98123456. If you need to narrow down please consider applying additional filters
     * @param sortOrder The order in which you require the results to be returned. Either ‘asc’ or ‘desc’
     * @param sortFields The fields that you require the ordering to be performed on. Multiple fields can be provided, separated by a comma.
     */
    public async retrieve(params?: {
        workspaceId: string,
        contactId: string,
        fields?: string,
        sortOrder?: 'asc' | 'desc',
        sortFields?: string,
    }, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage }> {
        const {
            workspaceId,
            contactId,
            fields,
            sortOrder,
            sortFields,
        } = params || {};

        const localVarPath = this.host + '/workspaces/{workspaceId}/contacts/{contactId}'
            .replace('{' + 'workspaceId' + '}', encodeURIComponent(String(workspaceId)))
            .replace('{' + 'contactId' + '}', encodeURIComponent(String(contactId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        if (fields !== undefined) {
            localVarQueryParameters['fields'] = ObjectSerializer.serialize(fields, "string");
        }
        if (sortOrder !== undefined) {
            localVarQueryParameters['sortOrder'] = ObjectSerializer.serialize(sortOrder, "'asc' | 'desc'");
        }
        if (sortFields !== undefined) {
            localVarQueryParameters['sortFields'] = ObjectSerializer.serialize(sortFields, "string");
        }
        localVarHeaderParams['Accept'] = 'application/vnd.whispir.contact-v1+json';
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            
                            resolve({ lastResponse: response.toJSON(), ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Creates a Contact object. The Contact can be used as a recipient when sending multi-channel messages.
     * @summary Create a contact
     * @param workspaceId The identifier for the workspace.
     * @param xApiKey The API key for authentication.
     * @param accept Application specific mime-type.
     * @param contentType Application specific mime-type.
     * @param contact Contact object to be created
     */
    public async create(params?: {
        workspaceId: string,
    } & Contact, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage, id: string } & Contact> {
        const {
            workspaceId,
            ...contact
        } = params || {};

        const localVarPath = this.host + '/workspaces/{workspaceId}/contacts'
            .replace('{' + 'workspaceId' + '}', encodeURIComponent(String(workspaceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        localVarHeaderParams['Accept'] = 'application/vnd.whispir.contact-v1+json';
        localVarHeaderParams['Content-Type'] = 'application/vnd.whispir.contact-v1+json';
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contact, "Contact")
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Contact");
                            
                            // Special case to extract the resource identifier from the `Location` header.
                            const checkLocation = response?.headers?.location?.match(/\/([^\/]+)\/?$/);
                            let id = (checkLocation && checkLocation[1]) ? checkLocation[1] : undefined;
                            
                            resolve({ lastResponse: response.toJSON(), id, ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * The application must provide all the fields during the update request, even if they are not being updated.  ## **NOTE:** Any missing fields will be automatically removed from the existing record.  **Note:** You cannot selectively update the contact fields needed as this is a PUT request.  1.  GET `/contact/{id of contact}` 2.  Update the contact field in the object to the required value 3.  PUT `/contact/{id of contact}` the new object  The response to the PUT request upon success is usually a 204 with no content being provided. 
     * @summary Update a contact
     * @param workspaceId The identifier for the workspace.
     * @param xApiKey The API key for authentication.
     * @param contactId Enter contact id.
     * @param accept Application specific mime-type.
     * @param contentType Application specific mime-type.
     * @param contact contact object that needs to be update contact
     */
    public async update(params?: {
        workspaceId: string,
        contactId: string,
    } & Contact, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage }> {
        const {
            workspaceId,
            contactId,
            ...contact
        } = params || {};

        const localVarPath = this.host + '/workspaces/{workspaceId}/contacts/{contactId}'
            .replace('{' + 'workspaceId' + '}', encodeURIComponent(String(workspaceId)))
            .replace('{' + 'contactId' + '}', encodeURIComponent(String(contactId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        localVarHeaderParams['Accept'] = 'application/vnd.whispir.contact-v1+json';
        localVarHeaderParams['Content-Type'] = 'application/vnd.whispir.contact-v1+json';
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contact, "Contact")
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            
                            resolve({ lastResponse: response.toJSON(), ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
