import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { GetDistributionLists200Response, GetDistributionLists200ResponseWrite } from '../model/getDistributionLists200Response';
import { GetMessages400Response, GetMessages400ResponseWrite } from '../model/getMessages400Response';
import { GetMessages401Response, GetMessages401ResponseWrite } from '../model/getMessages401Response';
import { GetMessages403Response, GetMessages403ResponseWrite } from '../model/getMessages403Response';
import { GetMessages404Response, GetMessages404ResponseWrite } from '../model/getMessages404Response';
import { GetMessages405Response, GetMessages405ResponseWrite } from '../model/getMessages405Response';
import { GetMessages415Response, GetMessages415ResponseWrite } from '../model/getMessages415Response';
import { GetMessages422Response, GetMessages422ResponseWrite } from '../model/getMessages422Response';
import { GetMessages500Response, GetMessages500ResponseWrite } from '../model/getMessages500Response';
import { GetMessages501Response, GetMessages501ResponseWrite } from '../model/getMessages501Response';
import { PostDistributionListsRequest, PostDistributionListsRequestWrite } from '../model/postDistributionListsRequest';
import { ObjectSerializer, Interceptor } from '../model/models';
import { HttpError, RequestFile, ApiConfig, RequestOptions } from './apis';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class DistributionListsApi {
    protected defaultHeaders: any = {};
    protected useQuerystring: boolean = false;
    protected interceptors: Interceptor[] = [];
    protected host: string;

    constructor(config: ApiConfig) {
        this.defaultHeaders = config.defaultHeaders;
        this.host = config.host;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * You can only delete the distribution list that you have created or a valid userId associated with the specific distribution list. 
     * @summary Delete a distribution list
     * @param workspaceId The identifier for the workspace.
     * @param xApiKey The API key for authentication.
     * @param distributionlistId The id of the distributionlists to be deleted
     */
    public async delete(params?: {
        workspaceId: string,
        distributionlistId: string,
    }, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage }> {
        const {
            workspaceId,
            distributionlistId,
        } = params || {};

        const localVarPath = this.host + '/workspaces/{workspaceId}/distributionlists/{distributionlistId}'
            .replace('{' + 'workspaceId' + '}', encodeURIComponent(String(workspaceId)))
            .replace('{' + 'distributionlistId' + '}', encodeURIComponent(String(distributionlistId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            
                            resolve({ lastResponse: response.toJSON(), ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * The distribution list is usually retrieved by its id, but one can also search or refer to the distribution list by its name. This feature has to do with the unique name requirement for the distribution list.  Apart from the name, the description field can also be used to search for a distribution list. While name can be directly used to send in messages, the description is solely for the purpose of search. Once search yields the required result, the mri has to be picked from the selected DL and then used to send the messages.  Both these operations can be performed by passing in the relevant search parameters in the URL as query params.
     * @summary List distribution lists
     * @param workspaceId The identifier for the workspace.
     * @param xApiKey The API key for authentication.
     * @param accept Application specific mime-type.
     * @param limit The number of records to be returned.
     * @param offset The record number to start returning from.
     * @param sortOrder The order in which you require the results to be returned. Either ‘asc’ or ‘desc’
     * @param sortFields The fields that you require the ordering to be performed on. Multiple fields can be provided, separated by a comma.
     * @param name Specifies the name of the Distribution List to be searched for. It is based on the uniqueness of the name of the Distribution List. If the name contains spaces it is suggested - but not required - to escape them
     * @param description Specifies the descrition for the Distribution List to be searched for. If the description contains spaces it is suggested - but not required - to escape them
     */
    public async list(params?: {
        workspaceId: string,
        limit?: number,
        offset?: number,
        sortOrder?: 'asc' | 'desc',
        sortFields?: string,
        name?: string,
        description?: string,
    }, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage } & GetDistributionLists200Response> {
        const {
            workspaceId,
            limit = 20,
            offset = 0,
            sortOrder,
            sortFields,
            name,
            description,
        } = params || {};

        const localVarPath = this.host + '/workspaces/{workspaceId}/distributionlists'
            .replace('{' + 'workspaceId' + '}', encodeURIComponent(String(workspaceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (sortOrder !== undefined) {
            localVarQueryParameters['sortOrder'] = ObjectSerializer.serialize(sortOrder, "'asc' | 'desc'");
        }
        if (sortFields !== undefined) {
            localVarQueryParameters['sortFields'] = ObjectSerializer.serialize(sortFields, "string");
        }
        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }
        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }
        localVarHeaderParams['Accept'] = 'application/vnd.whispir.distributionlist-v1+json';
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetDistributionLists200Response");
                            
                            resolve({ lastResponse: response.toJSON(), ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A distribution list allows you to associate the following:  *   **ContactIds** (type:String) is a comma separated list of Contact IDs that you would like added to the list. *   **UserIds** (type:String) specifies the Whispir Users that should also be notified when this list is used. *   **DistListIds** (type:String) specifies the nested lists that are contained within this distribution list.  Any or all three of these can be updated via the PUT method along with the DL properties (name, description, location etc).  The steps usually are:  1. Create a Distribution List (DL) 2. While creating the DL itself, you can put in the ContactIds, UserIds, distListIds (nested) so that the DL is created with those values readily placed in. 3. After the DL is created, if you want to add/update the values, then 4. Do a GET request to retrieve the specific DL.    -  This will return you the DL object 5. Modify the DL properties (name, description, contactIds, UserIds, dlIds, location etc) as needed 6. Do a PUT request to update the DL details    -  Successful update gives you a 204 No Content    -  The contactIds, userIds, distListIds can be passed all together in a single request.  Note: 1.  If an existing contactId is again added, it does neither throws an error, nor create two entries. The contactId is just neglected and only 1 record is maintained. 2.  If the PUT request was successful, the expected response code is a 204 No Content 3.  For Modifying the Location Information refer to Location Tags for Distribution Lists 
     * @summary Retrieve a distribution list
     * @param workspaceId The identifier for the workspace.
     * @param xApiKey The API key for authentication.
     * @param accept Application specific mime-type.
     * @param distributionlistId Enter Distribution id.
     */
    public async retrieve(params?: {
        workspaceId: string,
        distributionlistId: string,
    }, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage } & PostDistributionListsRequest> {
        const {
            workspaceId,
            distributionlistId,
        } = params || {};

        const localVarPath = this.host + '/workspaces/{workspaceId}/distributionlists/{distributionlistId}'
            .replace('{' + 'workspaceId' + '}', encodeURIComponent(String(workspaceId)))
            .replace('{' + 'distributionlistId' + '}', encodeURIComponent(String(distributionlistId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        localVarHeaderParams['Accept'] = 'application/vnd.whispir.distributionlist-v1+json';
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PostDistributionListsRequest");
                            
                            resolve({ lastResponse: response.toJSON(), ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Distribution lists can be created within the Default Workspace, or within a Specific Workspace. More information on Workspaces will be provided later in this documentation.  The MRI value is important here. It is the required unique identifier for any communications that are to be sent out to this distribution list. 
     * @summary Create a distribution list
     * @param workspaceId The identifier for the workspace.
     * @param xApiKey The API key for authentication.
     * @param contentType Application specific mime-type.
     * @param accept Application specific mime-type.
     * @param postDistributionListsRequest Distribution list object that needs to be create Distribution list
     */
    public async create(params?: {
        workspaceId: string,
    } & PostDistributionListsRequestWrite, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage, id: string } & PostDistributionListsRequest> {
        const {
            workspaceId,
            ...postDistributionListsRequest
        } = params || {};

        const localVarPath = this.host + '/workspaces/{workspaceId}/distributionlists'
            .replace('{' + 'workspaceId' + '}', encodeURIComponent(String(workspaceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        localVarHeaderParams['Content-Type'] = 'application/vnd.whispir.distributionlist-v1+json';
        localVarHeaderParams['Accept'] = 'application/vnd.whispir.distributionlist-v1+json';
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postDistributionListsRequest, "PostDistributionListsRequest")
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PostDistributionListsRequest");
                            
                            // Special case to extract the resource identifier from the `Location` header.
                            const checkLocation = response?.headers?.location?.match(/\/([^\/]+)\/?$/);
                            let id = (checkLocation && checkLocation[1]) ? checkLocation[1] : undefined;
                            
                            resolve({ lastResponse: response.toJSON(), id, ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Any or all three of these can be updated via the PUT method along with the DL properties (name, description, location etc).  The steps usually are: 1.  Create a Distribution List (DL) 2.  While creating the DL itself, you can put in the ContactIds, UserIds, distListIds (nested) so that the DL is created with those values readily placed in. 3.  After the DL is created, if you want to add/update the values, then 4.  Do a GET request to retrieve the specific DL.     - This will return you the DL object 5.  Modify the DL properties (name, description, contactIds, UserIds, dlIds, location etc) as needed 6.  Do a PUT request to update the DL details     - Successful update gives you a 204 No Content     - The contactIds, userIds, distListIds can be passed all together in a single request.  Note: - If an existing contactId is again added, it does neither throws an error, nor create two entries. The contactId is just neglected and only 1 record is maintained. - If the PUT request was successful, the expected response code is a 204 No Content - For Modifying the Location Information refer to Location Tags for Distribution Lists 
     * @summary Update a distribution list
     * @param workspaceId The identifier for the workspace.
     * @param xApiKey The API key for authentication.
     * @param contentType Application specific mime-type.
     * @param accept Application specific mime-type.
     * @param distributionlistId Enter Distribution id.
     * @param postDistributionListsRequest Distribution list object that needs to be update Distribution list
     */
    public async update(params?: {
        workspaceId: string,
        distributionlistId: string,
    } & PostDistributionListsRequestWrite, options?: RequestOptions): Promise<{ lastResponse: http.IncomingMessage }> {
        const {
            workspaceId,
            distributionlistId,
            ...postDistributionListsRequest
        } = params || {};

        const localVarPath = this.host + '/workspaces/{workspaceId}/distributionlists/{distributionlistId}'
            .replace('{' + 'workspaceId' + '}', encodeURIComponent(String(workspaceId)))
            .replace('{' + 'distributionlistId' + '}', encodeURIComponent(String(distributionlistId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);

        let localVarFormParams: any = {};
        localVarHeaderParams['Content-Type'] = 'application/vnd.whispir.distributionlist-v1+json';
        localVarHeaderParams['Accept'] = 'application/vnd.whispir.distributionlist-v1+json';
        (<any>Object).assign(localVarHeaderParams, options?.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this.useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postDistributionListsRequest, "PostDistributionListsRequest")
        };

        let authenticationPromise = Promise.resolve();

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }

            return new Promise((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            
                            resolve({ lastResponse: response.toJSON(), ...body });
                        } else {
                            reject(new HttpError(body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
